## 범위

- 프로그램이 어떤 식별자에 접근할 수 있는 영역
- C의 변수는 `블록범위(중괄호)`, `함수 프로토타입 범위`, `파일 범위` 중 어느 한가지 범위를 가진다.
- 내부 블록에 선언된 변수는 그 블록에만 한정된 범위를 가진다.
- 함수 프로토타입 범위는 함수 프로토타입에 사용되는 변수 이름들에 적용된다

  ```java
  int mighty(int mouse,double large);
  ```

  - 함수 프로토타입 범위는 변수들이 정의된 지점부터 프로토타입 선언의 끝까지.
  - 함수 프로토타입 전달인자를 처리할 때 컴파일러는 오로지 데이터형에만 관심이 있다는것!
  - 정의가 어떤 함수에도 속하지 않고 함수들의 바깥에 놓여있는 변수는 파일범위를 가진다. (보통 전역에 선언한 경우)

  ```java
  int units; // 파일범위를 가진다
  int main(){

  }

  void critic(void){

  }
  ```

  - units는 main과 critic에서 모두 사용가능
  - 파일범위변수들은 전역변수라고도 부른다!

## 연계

- 연계는 내부연계,외부연계,무연계로 나뉨
- 블록범위, 함수범위변수 즉 함수 프로토타입 변수는 연계를 가지지 않는다.
  - 그들이 정의된 블록이나 함수, 즉 함수 프로토타입에만 적용
- 파일범위 변수들은 내부연계나 외부연계중 하나를 가질 수 있음
  - 외부연계 가지는 변수는 다중 파일 프로그램의 어디에나 사용가능
  - 내부연계 가지는 변수는 한 파일안의 어디에나 사용가능
- 외부연계와 내부연계를 어떻게 구분?

```java
int giants = 5; //파일범위, 외부연계
static int dodgers = 5; //파일범위, 내부연계
```

- giants는 동일한 프로그램을 구성하는 `다른 파일에서도 사용 가능`
- dodgers는 `이 특정파일에서만 유효` , 그 파일에 있는 모든 함수들이 사용 가능

## 저장수명

- 식별자들로 접속하는 객체들의 지속성을 나타냄
- C 객체의 수명은 아래 4가지 중 한가지의 수명을 가진다
  - 정적 수명
  - 스레드 수명
  - 자동 수명
  - 할당된 수명
- 정적 수명
  - 프로그램이 실행되는 동안에 내내 존재
  - static은 수명이 아니라 연계유형을 나타냄
  - static을 선언하면 한 파일 범위 변수는 내부 연결을 갖지만 내부연결이나 외부 연결을 사용한 모든 파일 범위 변수들은 정적 수명을 가진다.
- 스레드 수명
  - 프로그램 실행이 **여러 스레드로 분할 될 수 있는** 동시 프로그래밍으로 실행되게됨.
  - 스레드가 선언됐을 때 부터 종료될때까지 존재
  - 파일 범위 객체가 선언되거나 키워드 **Thread ** local로 수정되는 파일범위객체가 만들어지거나 할 때 만들어짐.
  - 이러한 지정자로 변수가 선언되면 각 스레드는 그 변수의 자체 비밀 복사본을 가짐.
- 자동수명

  - 블록범위변수들에 해당
  - 그들이 정의된 블록에 프로그램이 진입할때 메모리가 할당, 프로그램이 블록을 탈출할때 메모리가 해제
  - 지역변수들도 자동수명 가짐
  - 변수는 블록범위를 갖는 동시에 정적인 수명을 가질 수있다.
  - 블록범위에서 선언하고 키워드 static을 추가하면 됨

  ```java
  void func(int number){

  	static int ct = 0;

  }
  ```

  - ct가 정적메모리에 저장된다.
  - 프로그램이 로드된때부터 종료된때까지 more함수 블록으로 한정됨

## 레지스터 변수

- 일반적으로 변수는 컴퓨터의 메모리에 저장됨
- 레지스터 변수는 블록범위,무연계,자동수명을 가짐 (주소가 없다!)
- 레지스터 변수는 register 키워드를 사용하여 선언

## 블록범위 정적변수

- 정적의 의미?
  - 변수가 메모리에 그대로 유지되는것을 말함
- 정적수명을 가지는 블록범위의 지역변수들도 생성할 수 있다.
  - 정적 변수들도 자동변수들과 같은 범위를 가지지만! 함수가 일을 끝냈을때 소멸되지는 않는다.
  - 블록범위,무연계,정적수명을 가진다
  - static 쓸거면 함수 안에서 쓸 것
    - 이름 충돌등 예상치못한 상황 방지 위함
  - 함수의 매개변수에는 static을 쓰면 안된다.

## 외부연계 정적변수

- 외부변수라고 부르는데 어떤 함수에 속하지 않게 함수의 외부에 정의선언을 둔것

```java
double up[100];

int main(void){
	extern double up[];
}
```

- extern 선언을 하게 되면 크기지정을 할 필요가 없어진다!
- 외부변수는 정적 저장수명을 가진다.

## 내부연계 정적변수

- 정적수명, 파일범위, 내부연계를 가진다.
- 어떤 함수들에 속하지 않고 함수 바깥에 저장클래스 지정자 static을 사용하여 정의

## 저장클래스 지정자 모아보기

- C언어는 저장 클래스 지정자로 묶을 수 있는 6가지 키워드가 존대한다.
  - auto
  - register
  - extern
  - \_\_ Thread_local
  - typedef
- auto
  - 자동수명을 가지는 변수
  - 자동수명을 가지는 블록범위 변수선언에만 사용가능
  - 문서화할때 사용
- register
  - 블록범위 변수에만 사용가능
  - 접속시간 최소화를 위해 변수를 레지스터 저장클래스에 넣어줄것을 컴파일러에게 부탁
- static
  - 정적인 수명을 가진 객체를 만들 수 있다.
  - 파일범위선언과 사용될때
    - 범위는 한 파일로 제한
  - 블록범위선언과 사용될때
    - 범위는 그 블록에 제한
- extern
  - 어딘가에 이미 정의된 애를 재선언하는것을 나타냄
  - 참조선언이기때문에 다른 선언들을 정의 선언이 하나만 있어야하는 반면 애는 원하는 대로 마음껏 넣을 수 있다.
  ```java
  extern int roll_count; //헤더
  int roll_count = 0; //소스코드
  ```

## 저장클래스 함수

- 함수들도 외부(디폴트)또는 정적 둘 중 클래스를 가진다.
- static함수 왜 쓸까?
  - 함수들을 특정모듈에만 사용할 수 있게 만들어 이름 충돌 가능성 피하는 것
- extern함수 쓰는경우?
  - 다른 파일에 정의된 함수 선언할때 사용
  - static키워드 사용하지 않는 한 함수 선언은 항상 extern
- 어떤 저장클래스를 사용할 것인가?
  - 대부분은 자동변수!
  - 외부변수는 왜 안쓰지? 이러면 포인터나 전달인자에 대해 고민할 필요도 없는데!
    - 함수들에서 사용하는 변수들이 바뀌지 않을지 항상 노심초사해야함

## malloc()과 free()

- 이전까지는 사용할 저장클래스들을 결정하면 범위와 수명이 자동으로 정해졌다.
- C는 프로그램이 실행될때 사용자가 직접 메모리를 할당할 수 있다. → malloc()
- 전달인자로 원하는 만큼의 메모리 바이트 수를 사용한다 → 자유 메모리공간에서 적당한 블록을 찾는다
- malloc()은 메모리를 할당하지만 거기에 이름을 붙이지 않는다. (익명)
  - 그 블록의 첫번째 바이트 주소를 리턴한다. 그러므로 어떤 포인터 변수에 그 주소를 대입가능
  - 그 포인터 사용하여 그 메모리에 접근할 수 있는것.
- malloc()은 전통적으로 char형을 가리키는 포인터형으로 정의되어옴 → 이제는 void형(범용포인터)
- malloc()은 배열,구조체,기타 등등을 가리키는 포인터를 리턴할 수 있다.
- 리턴값은 데이터형 캐스트를 사용하여 적당한 값으로 변환됨
- malloc()은 적당한 메모리 공간을 찾지 못하면 널포인터 리턴

```java
double *ptd;
ptd = (double*) malloc(30*sizeof(double));
```

- 30개의 double형 값을 저장하기 위한 공간을 요청하고 ptd가 그 위치를 가리키도록 설정
- ptd가 double형 값 30개 가지는 블록을 가리키는 포인터가 아니라 **하나의 double형 값을 가리키는 포인터로 선언됨**
- malloc()은 free()와 함께 사용해야한다.
  - free()는 전에 malloc()이 리턴했던 주소를 전달인자로 사용하여 할당했던 메모리를 해제한다
  - 둘다 stdlib.h 헤더파일에 프로토타입이 들어있다.
- calloc()함수
  - 첫번째 인자는 사용자가 원하는 메모리 셀의 개수
  - 두번째 인자는 각 셀의 바이트 수
  - 할당된 블록의 모든 비트를 0으로 설정한다.

## 동적 메모리 할당과 가변길이 배열

- VLA는 자동저장클래스이다. 그렇기에 메모리 공간이 자동으로 해제된다.

## 저장 클래스와 동적 메모리 할당

- 정적수명 저장 클래스들에 필요한 메모리 양은 컴파일 될 때 결정
  - 이 영역에 저장되는 데이터는 프로그램이 실행되는 동안 계속 사용 가능
  - 프로그램이 시작될 때 생성되고 종료될때 소멸
- 자동변수의 경우 코드 블록에 진입할 때 생성, 탈출할 때 소멸
  - 자동변수들의 메모리 양이 커졌다 작아졌다함
  - 메모리 영역은 스택으로 처리됨.
- 동적으로 할당되는 할당되는 데이터는 힙에 저장됨

## const 데이터형 한정자

- 포인터의 경우 조심해야함.
- 포인터 자체를 const로 만든 경우
  ```java
  float *const pt;
  ```
- 포인터가 가리키는 값을 const로
  - 이때는 pt 자체의 값은 변경 가능
  - 다른 const 가리키게 가능
  ```java
  const float *pt.
  ```
- 암기 시 데이터형과 const사이에 \*을 넣는다 → 포인터 자체를 const로
