# 13장 파일 입출력

## 파일이 뭐지?

- c언어에서 파일을 각 바이트를 개별적으로 읽을 수 있는 연속적인 바이트들의 시퀀스로 인식
- 텍스트인식과 바이너리 인식을 제공
- 모든 파일 컨텐츠는 이진법 형태이다
  - C 문자열 만큼 많은 문자를 표현하기 위해 이진 코드 사용 → 텍스트 파일
  - 파일안에 이진 값들이 기계어 코드 또는 수치데이터 표현 → 바이너리
- 파일에 엑세스 하는 방식
  - 텍스트모드
  - 바이너리 모드

## 입출력수준

- 저수준 입출력
  - 운영체제가 제공하는 기본 입출력
- 고수준 입출력
  - c라이브러리 함수들의 표준 패키지와 stdio.h 헤더파일들의 정의 사용

## 표준 파일

- 표준입력, 표준 출력,표준 에러 출력 세가지 파일을 자동으로 연다
  - 표준 출력과 표준 에러 출력은 디폴트
  - 표준 입력은 getchar(),gets(),scanf()가 데이터를 읽는 파일
  - 표준 출력은 프로그램의 정상적인 출력이 나타남 putchar(),puts(),printf()

## 표준입출력

- 입출력 문제들을 간단하게 처리하는 전문화된 많음 함수들을 제공
- 입력과 출력에 버퍼 제공
  - 한번에 한바이트씩 전달 x 큰덩어리로 전달
  - 한 덩어리의 데이터가 버퍼에 복사됨 → 데이터 전송속도를 크게 증가시킴

## 명령행 전달인자 검사하기

```java
int main(int argc, char* argv[]){

}
```

- int argc는 main() 함수에 전달되는 **정보의 개수**를 의미하고 char \*argv[]는 main() 함수에 전달되는 **실질적인 정보로 문자열의 배열**을 의미한다.
- 명령행 전달인자가 있는지 확인하기 위해 argc의 값을 검사
  - exit()는 열려있는 모든 파일들을 닫으면서 프로그램을 종료시킴
- 정상적으로 종료되는 경우 0을 전달, 비정상적으로 종료되는 경우 0이 아닌 값들을 전달
- return과 exit()의 차이
  - return의 경우 다른 함수에서 호출되면 프로그램 종료x
  - exit()은 다른 함수에서 호출돼도 프로그램 종료

## fopen()함수

- stdio.h에 선언됨
- 첫번째 전달인자는 열려고 하는 파일의 이름 (그 파일 이름을 가지고 있는 문자열의 주소)
- 두번째 전달인자는 파일을 여는데 사용할 모드를 지정하는 문자열
  - r : 읽기 위해 텍스트모드로 연다
  - w : 쓰기 위해 텍스트모드로 연다 파일이 이미 존재하면 파일 길이를 0으로, 없으면 새 파일을 만든다.
  - a : 쓰기 위해 파일을 텍스트 모드로, 파일이 이미 존재하면 그 파일의 끝에 덧붙임ㄴ
  - r+,w+,a+ : 갱신하기 위해(읽고 쓰기)
  - b가 뒤에 붙으면 (rb,wb..) → 바이너리 모드로 동작
- 프로그램이 성공적으로 파일을 열면 fopen()은 파일 포인터를 리턴.
- 파일 포인터는 실제 파일을 가리키지 않음!
  - 파일의 입출력에 사용되는 버퍼 정보를 포함
  - 그 파일에 관한 정보가 들어있는 데이터 객체까지 가리킴.
- 파일을 열 수 없을 때 널 포인터 리턴
  - 디스크가 꽉 차 있을 때, 파일이 찾는 디렉토리에 없을 때 등등

```java
fp=fopen(file,"rb");
```

# getc()와 putc()함수

- 어느 파일을 사용할것인지 알려줘야 한다.

```java
ch = getc(fp);
```

- fp가 나타내는 파일로부터 하나의 문자를 얻는다.

```java
putc(ch,fpout); // fpout도 stdout이다!
```

- 문자 ch를 FILE포인터 fpout이 나타내는 파일에 출력한다.

## 파일의끝(EOF)

- getc()는 파일 끝에 도달함을 발견하면 EOF리턴
- getc()는 어떻게 설계하는게 좋을까?
  - 비어있는지 먼저 확인하고 들어가는게 좋다!

```java
int ch;
FILE* fp;
fp = fopen("어쩌구.txt","r");
ch=getc(fp);
while(ch!=EOF){

	putchar(ch);// 입력처리
	ch = getc(ch); // 다음 입력 얻기

}
```

## fclose()함수

- 필요할 때 버퍼 비우면서 fp가 가리키는 파일을 닫는다.
- 파일을 성공적으로 닫으면 0리턴, 그렇지않으면 EOF리턴
- 디스크가 가득차있거나 플로피 디스크가 제거 되었을때, 입출력 에러 발생시 파일 닫는데 실패할 수 있음

## 표준 파일을 가리키는 포인터

| 표준파일  | 파일 포인터 | 일반적으로 |
| --------- | ----------- | ---------- |
| 표준 입력 | stdin       | 키보드     |
| 표준 출력 | stdout      | 스크린     |
| 표준 에러 | stderr      | 스크린     |

## 파일 입출력

- 파일입출력 함수들에게 **어느 파일을 가지고 작업할 것인지** 알려주기 위해 파일 포인터를 사용할 필요가 있다.

### fprintf()와 fscanf()함수

- 적당한 파일을 나타내는 부가적인 첫번째 전달인자를 요구하는 것만 제외하고 printf(),scanf()와 동일하게 작동함

```java
fprintf(stdout,"파일을 열수 없습니다");
rewind(fp);
```

- rewind()는 파일포인터를 파일의 시작으로 옮긴다. 파일 포인터를 전달인자로 사용

### fgets()와 fputs()함수

- fgets()는 세개의 전달인자 사용
  - 입력을 저장할 주소 → buf,char형 배열 이름
  - 입력 문자열의 최대 크기를 나타내는 정수
  - 읽을 파일을 가리키는 파일 포인터 → fp
  ```java
  fgets(buf,STLEN,fp);
  ```
- fputs()는 두개의 전달인자 사용
  - 문자열의 주소
  - 파일 포인터 (타깃 파일)
    ```java
    fputs(buf,fp);
    ```

### fseek()와 ftell()

- 임의접근시 사용
- fseek()함수는
  - 파일을 마치 배열처럼 다룰 수 있게함
  - fopen()에 의해 열려진 파일들에 들어있는 특정바이트로 직접 이동하게 함
  - int형 리턴
- ftell()함수는
  - 파일에서 현재 위치를 long형으로 리턴

### fseek()와 ftell()은 어떻게 동작하는가?

- fseek()
  - 세개의 전달인자 사용
  1. 처리할 파일을 가리키는 FILE포인터 (이 파일은 fopen()함수에 의해 미리 열려있어야)
  2. 오프셋 (시작 위치로부터 얼마나 멀리 가야하는지, long형이여야)
  3. 모드
  - 성공적이면 0 리턴, 에러가있으면 -1리턴
  ```java
  fseek(fp,0L,SEEK_SET); // 파일의 시작으로 간다.
  ```
- ftell()
  - 현재 파일의 위치 리턴
  - 파일의 시작으로부터 첫바이트를 0으로 하는 바이트 수 리턴함으로써 파일의 위치 지정
  ```java
  fseek(fp,0L,SEEK_END);
  ```
  - 파일의 위치를 파일의 끝에서 0바이트 오프셋으로 설정
  - 파일의 위치를 파일의 끝으로 설정

### fgetpos()와 fsetpos() 함수

- fseek()와 ftell()의 잠재적인 문제는 함수 들이 파일 크기를 Long형으로 제한했다는것!

```java
int fsetpos(FILE* restrict stream,const fpos_t *pos);
```

- fpos_t의 값을 pos가 가리키는 위치에 넣는다 성공하면 0 리턴, 아니면 0이 아닌 값 리턴
- 그 값은 파일 안에서 어떤 위치 나타냄

### 바이너리 입출력 : fread()와 fwrite()

- 수치 데이터를 파일에 저장할 때
- 바이너리 서비스 제공
- 바이너리 데이터를 읽고, 파일에 저장한다고 보면 됨.

## 리캡

- 어떤 파일에 접근 하려면 → 파일포인터(type FILE\*)를 생성하고 그 포인터를 하나의 특정한 파일 이름에 연결해야한다.
- 프로그램은 파일을 다룰때 파일 이름이 아니라 파일 포인터를 사용함.
