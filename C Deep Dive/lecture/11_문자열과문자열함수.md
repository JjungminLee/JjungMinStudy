# 11장 문자열과 문자열 함수

## 문자열 표현과 문자열 입출력

- puts()함수
  - printf()함수처럼 입출력 함수군의 stdio.h계열에 속함
  - 자동으로 개행을 첨부한다!
- 문자열 상수 (문자열 리터럴)
  - 큰따옴표로 둘러싼 모든것
  - 컴파일러가 자동으로 삽입하는 종결 널 문자 \0 까지 포함하여 메모리에 문자열로 저장된다
- 문자열도 배열이기에 포인터로 나타낼 수 있다!
  ```java
  const char *pt1 = "Something is rarara";
  const char ar1[] = "Something is rarara";
  ```
- 큰 따옴표로 있는 문자열은 → 정적메모리에 있다고 말함 (정적메모리에 있는 문자열 상수)
- 배열을 위한 메모리 할당은 → 프로그램 시작 후에 이루어짐 → 이 시점에서 큰 따옴표로 둘러싸인 문자열이 배열에 복사됨 (ar1배열에 있는 문자열)
- 중요한 점은 ar1이 주소 상수라는 점!
  - 고로 ar1+1 은 가능하지만 ++ar은 불가능 (증감연산자는 변수에만 사용가능! 상수에는 불가능!)
- 문자열 리털은 const데이터로 간주된다.

- 그래서 하고 싶은 말이 뭔데?

### 배열의 초기화는 정적 메모리에서 배열로 그 문자열을 복사

### 포인터의 초기화는 문자열의 주소만 복사

## 문자열을 바꿀 계획이 있다면 포인터를 사용하지 말 것!

```java
char* p1 = "Klingon";
```

이런식으로 해버리면 컴파일러가 단일본 표현방식을 사용하기에 문자열이 사용되는 모든곳에 영향을 받을 것

```java
const char* p1 = "Klingon";
```

만약 쓴다면 이런식으로 const 변경자 사용하는 것이 바람직

## 포인터 배열과 배열 포인터

```java
const char *arr[3]; // 포인터 배열
const char (*arr)[3]; //배열 포인터
```

- 포인터 배열은 포인터들의 배열
  - **배열의 요소가 포인터**
  - **포인터가 여러개 모여서 배열로 구성된 것**
- 배열 포인터
  - 그냥 얘는 포인터라고 생각하셈
  - **배열 타입을 가리키는 하나의 포인터**

## 문자열을 저장하려면 기억 공간 부터 만들자!

```java
char* name;
scanf("%s",name);
```

- 컴파일러는 이 코드를 통과 시키지만 프로그램을 먹통으로 만들것
- scanf는 전달인자로 제공된 주소에 그 정보를 복사함 → 근데 예시의 경우 초기화 되지 않은 포인터
- 고로 제멋대로 어딘가를 가리킬것!

## 문자열을 읽을 수 있는 함수 - scanf(), gets(), fgets()

### gets()

- scanf의 경우 한단어만 읽는데 얘는 입력줄 전체를 읽는다!
- 개행문자에 도달할때까지 전부를 읽는다.
- 개행문자 제거 후 C문자열을 만들기 위해 널 문자 추가하여 남은 문자 저장한다.
- gets()와 puts()는 짝꿍!

```java
# define STLEN 81
int main(void){
	char words[STLEN];
	puts("문자열을 입력해주세요");
	gets(words);
}
```

- 컴파일러가 경고 메세지를 띄우는데 이유는 gets()가 입력행이 실제로 배열에 딱 맞는지 볼 수 있도록 점검하지 않음 배열이 어디서 시작하는지만 알지 원소가 몇개인지는 모른다
- segmentation fault : 프로그램이 할당되지 않은 메모리에 접근한다는 에러
- 근데 보안상 안좋으니까 쓰지 마라

### fgets()

- 읽을 문자들의 최대 개수를 지정함으로써 두번째 전달 인자를 취할 때 생기는 오버플로 문제 해결함
- 얘는 태생이 파일입출력 때문에 생겨난 것이므로 키보드 입출력에는 불편함
- gets()와 다른점 세가지
  1. 읽을 문자들의 최대 개수를 지정하기 위해 두번째 전달인자를 사용한다. 전달인자가 n이라면 fgets()는 n-1개까지 문자들을 읽는다.
  2. fgets()는 개행문자를 읽어 그 문자열에 저장한다. gets()는 읽고 걍 버린다.
  3. 어느 파일을 읽은 것인지 지정하기 위해 세번째 전달인자를 사용한다. 키보드로부터 읽으려면 stdin을 전달인자로 사용한다.
- fgets() 함수가 문자열의 부분으로서 개행을 포함하기 때문에 fputs()함수와 짝꿍을 이루어 사용됨.
- 근데 fputs()함수는 자동으로 개행을 추가하진 않음!
- 정리 fgets()는 개행 포함, fputs()는 개행 포함 X

```java
# define STLEN 81
int main(void){
	char words[STLEN];
	puts("문자열을 입력해주세요"); // 얘는 개행을 추가한다!
	fgets(words,STLEN,stdin);
	fputs(words,stdout);
}
```

- fgets()의 EOF는 fgets(words,STLEN,stdin) == NULL
- 만약 개행을 제거하고 싶다면?!
  ```java
  while(words[i]!='\n')
  	i++;
  words[i]='\0';
  ```

### 널 문자와 널 포인터

- 널 문자 ‘\0’는 문자열의 끝을 표시하는데 사용됨 (정수형)
- 널포인터 NULL은 파일의 끝을 만나거나 예상했던대로 실행했는데 실패한 경우 특별한 발생을 나타내기 위해 유효 주소 반환하는 함수에서 사용 (포인터형)

### gets_s()함수

```java
gets_s(words,STLE);
```

- fgets()함수와의 차이점
  - 표준 입력만 읽어 세번째 전달인자가 필요없음
  - 개행을 읽는 경우 개행문자를 저장하는 대신 버림
  - 문자를 최대치 까지 읽고 개행을 읽는데 실패한 경우
    - 목표배열의 첫번째 문자를 널문자에 맞추어 놓는다.
    - 개행또는 파일끝을 만날때까지 읽고 그 이후의 입력은 버린다.
    - 이후 널 포인터 리턴
- 아무튼 fgets() 써라

### scanf()함수

- scanf() gets() fgets()의 주요한 차이는 → 문자열의 끝에 **언제 도달하는지 결정하는** 방법
- scanf()는 문자열함수 이기보단 단어입력 함수
- 대표적인 용도는 데이터형들이 혼합된 입력을 읽고 그들을 표준형식으로 변환하는 것

## 문자열 출력함수 - puts(), fputs(), printf()

### puts()함수

- 문자열의 주소를 전달인자로 전달하기만 하면 끝!

```java
puts("어쩌구저쩌구");
puts(str1);
puts(&str1[5]);
```

- puts()는 문자열 출력시 자동으로 개행을 추가한다.
- puts()는 널문자를 만났을 때 멈추므로 반드시 널문자 추가해야!

### fputs()함수

- puts()함수의 파일지향 버전
- fputs()함수는 출력할 **타깃파일**을 지정하기 위해 두번째 전달인자 사용
- 자동으로 개행을 추가하지 않음

| gets()  | 입력에 개행을 읽고 버린다.                           |
| ------- | ---------------------------------------------------- |
| puts()  | 출력에 개행을 추가한다.                              |
| fgets() | 입력에 개행 문자를 저장한다. → 이후 꼭 삭제해줘야함! |
| fputs() | 출력에 개행문자를 추가하지 않는다.                   |

### printf()함수

- 문자열 주소를 전달인자로 사용한다.

## 사용자 정의 출력함수

- getchar()와 putchar()에 기초하여 직접 만들 수 있음
- string이 널문자를 가리킬 때 0을 가짐 → 종료

## 문자열 함수 - strlen(), strcat(), strncat(), strcmp(), strncmp(), strcpy(), strncpy()

### strlen()

- 문자열의 길이를 구하는 함수

### strcat()

- 두개의 문자열이 전달인자
- char\*형 (char형을 가리키는 포인터)
- 이 함수는 첫번째 전달인자와 두번째 전달인자를 덧붙은 첫번째 문자열의 첫번째 문자의 주소를 리턴
- 버퍼오버플로우를 일으킴

### strncat()

- 두번째 문자열이 첫번째 배열에 맞는지 검사하지 않는다.
- strncat(bugs,addon,13)
  - addon내용을 bugs에 추가
  - 문자개수가 13개에 도달하거나 널문자에 도달하면 추가를 멈춘다 → 둘중 먼저 일어나는걸 실행
- strcat()대신 strncat() 쓸것!

### strcmp()

- while(try≠ANSWER) 이런식으로 문자열 비교할때는 문자열을 검사하는게 아니라 실질적으로는 **포인터를 검사함.**
- 두 문자열의 주소가 같은지 검사하는데 사실상 둘이는 다른 주소에 있기 때문에 틀렸다는 대답을 끊임없이 듣게 될 것.
- strcmp()는 문자열 내용이 같은지 비교하는 함수.
- 같으면 0 , 같지 않으면 0이 아닌 수를 리턴함
- strcmp(try,ANSWER)≠0 이런식으로 써야함
- strcmp의 멋진 기능중 하나는 배열들이 아닌 문자열들을 비교하는 것
- strcmp는 어떤값을 리턴할까?
  - strcmp(”A”,”B”) → -1 A가 B보다 알파벳 순서가 먼저이기 때문
  - strcmp(”A”,”A”) → 0
  - strcmp(”B”,”A”) → 1

### strcpy()와 strncpy()

- ptr1과 ptr2가 문자열을 가리키는 포인터일때

```java
ptr2 = ptr1;
```

- 이건 문자열 자체가 아니라 문자열의 주소만을 복사
- 문자열 자체를 복사하고 싶다면? → strcpy()함수를 쓰기!
- strcpy는 두개의 문자열 포인터를 전달인자로 사용
- strcpy는 char\*형이다
  - 첫번째 전달인자의 값 - 문자의 주소를 리턴한다.
- 첫번째 전달인자가 반드시 배열의 시작을 가리킬 필요는 없다.
- 근데 strcypy()는 gets()처럼 문자열이 맞는지 검사하지 않기 때문에 strncpy()쓰는것을 권장.

```java
strncpy(target,source,n);
```

- n개의 문자들까지 또는 널 문자를 만날때 까지 source에서 target으로 복사한다.

### ctype.h

- 문자열에 전체적으로 적용될 수는 없지만 문자들에는 적용 가능!
- 대문자로 바꾸기 ToUpper()같은 함수들이 구현되어 있음
- 보통 매크로로 구현되어있다.
