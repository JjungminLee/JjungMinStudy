## 함수 프로토타입의 작성

```java
void show_n_char(char ch,int num);
```

- 이런식으로 프로토타입을 사용할 수 있고 변수 이름을 생략한 형식으로 사용 가능

## 전달인자가 없는 경우와 지정되지 않은 전달인자

- 함수가 전달인자를 사용하지 않는다면 void키워드를 넣어야한다.

```java
void print_name(void)l
```

## 꼬리재귀

- 재귀 호출이 함수의 끝 return문 바로 앞에 있는것
- 재귀호출이 끝에서 일어난다 정도로 생각
- 꼬리 재귀는 루프처럼 동작
- 재귀는 보기에 편하다는 장점이 있지만 변수의 중복생성이 발생한다는 단점을 항상 생각할것 !

## Linux에서 둘 이상의 소스코드 파일로 된 프로그램 컴파일하기

- GCC컴파일러 사용
- 두개의 파일 file1.c와 file2.c에 C함수들이 있으면
- gcc file1.c file2.c 라는 명령어를 통해 파일을 컴파일해 a.out이라는 실행파일을 만든다.
- 또한 file1.o 와 file2.o라는 오브젝트 파일도 만들어짐
- 나중에 file1.c를 수정하고 file2.c를 수정하지 않았을 경우 gcc file1.c file2.o 라는 명령어는 소스 파일만 컴파일하여 두번째 오브젝트 파일과 결합시킴

## 헤더파일

- 프로그램에서 사용할 상수를 정의하기 위해 C전처리기 사용
- #define 지시자가 있는 파일에만 적용
- 프로그램이 사용하는 함수들을 여러 파일에 나누어 놓았다면 각가의 파일이 #define 지시자 사용하게 해야함.
- 함수 프로토타입과 상수 정의를 하나의 헤더 파일에 모아놓는것을 권장

## 포인터

```java
ptr = &pooh;
```

- pooh의 주소를 ptr에 대입한다.
- ptr은 변수이고 &pooh는 상수

```java
val = *ptr
```

- ptr이 가리키고 있는 주소의 값
- 포인터는 함수안의 변수들이 지역적이라는 것을 극복하게 해준다.

## 함수

- 함수는 기본적으로 UI와 기능을 분리해야한다!

## 이벤트 루프

- 사용자 입력에 의해 이벤트 발생
  - 키보드,마우스
- main()함수에서 사용자 인터페이스 출력 및 사용자 입력을 반복하는 구조
- 대부분의 응용프로그램이 채택하는 기본적 구조

## 함수 원형 선언

- 함수의 선언과 정의 분리
- 컴파일러에게 함수의 존재 알리기 위해 분리한 선언을 코드 상단에 기술
- 함수 바디 없이 원형만 기술할 경우 함수 시그니처라고 부르기도함
- 함수 원형 선언에서는 매개변수 이름은 생략 가능

## 분한 컴파일

- 하나의 프로젝트에 여러 소스코드파일(.c)를 운영하는 경우 각각을 개별 컴파일
- 개별 소스코드에 대한 목적파일 생성
- 변수나 함수 선언과 정의가 다른 파일로 분리될 수 있음
  - A.c에서 Add()가 있고 B.c에서 Add()가 있으면 에러가 남!
  - A.c에서 선언만 있고, B.c에서 정의를 해주면 링크 과정에서 오류를 줄일 수 있다.
  - 헤더파일 → 선언만 모아놓음!
- 링크 오류주의!
- 코드 나눠져있고 + 이거 컴파일한다음에 + 링킹 (합성)

## 전역변수와 식별자 검색 순서

- 전역변수는 함수 바디 밖에 선언
- 식별자 검색 순서
  - 지역 스코프
  - 최대 함수 바디
  - 최대 로컬 파일
  - 외부 파일까지 확장
- 전역변수는 꼭 필요할때만 쓰기! 웬만하면 안 쓰는걸 추천
  - 전역변수는 정적 영역을 사용
  - 지역변수는 stack을 사용
- 외부파일 extern
  - 선언은 A.c에 있는데 정의는 B.c에 있을경우 extern사용

```c
extern int g_input; // 이 변수 A.c에 없고 다른 파일에 있어요!
```

- `extern선언은 어딘가에서는 정의해줘야한다!`
