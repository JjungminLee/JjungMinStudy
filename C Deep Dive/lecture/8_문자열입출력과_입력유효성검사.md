# 8장 문자열 입출력과 입력 유효성 검사

## 단일 문자 입출력 - getchar()와 putchar()

- 한번에 한문자씩 입출력 수행
- 입력의 에코
  - 키보드 입력으로부터 문자들을 읽어 화면으로 보내는것

## 버퍼

- 버퍼를 사용하는 이유?
  1. 문자들을 묶어서 전달하는게 하나씩 전달하는 것보다 시간을 적게 소모
  2. 잘못 타이핑 했을 때 키보드 기능을 사용해 실수를 고칠 수 있음
- 버퍼링 종류
  - 완전 버퍼링 입출력
    - 가득 찼을 때 버퍼가 비워진다.
    - 일반적으로 파일입출력에서 일어남.
  - 라인-버퍼링 입출력
    - 개행문자가 나타날때 버퍼가 비워진다.
    - 일반적으로 키보드 입력은 라인-버퍼링 입출력

## 키보드 입력 끝내기

- C가 파일을 처리하는 방법
  - 파일은 정보가 저장되어있는 메모리의 어떤 영역
  - 파일은 주로 영구 메모리에 저장됨
  - C프로그램은 파일을 직접 다루지 않고 스트림을 다룬다.
    - 스트림이란 실제의 입력이나 출력이 맵핑된 데이터의 이상화된 흐름
    - 파일을 여는 과정은 하나의 스트림을 그 파일에 연결하는 과정이 됨.
  - 이러면 키보드와 디스플레이 장치가 C프로그램에 의해 자동으로 열리는 파일처럼 다루어짐.
    - 키보드 입력은 stdin 스트림
    - 화면 출력은 stdout 스트림
    - getchar() putchar() printf() scanf() 함수들 모두 표준 입출력 패키지의 멤버들

## 파일의 끝

- os는 각각의 파일이 어디에서 시작하고 어떻게 끝나는지 말해주는 방법이 필요

  - 끝을 표시하는 어떤 문자를 파일에 집어넣어보자!

    1. Ctrl+z
    2. 운영체제가 파일 크기에 대한 정보 저장
    3. C는 운영체제가 파일 끝을 실제로 탐지하느냐에 관계 없이 파일의 끝에 도달했을 때 getchar()함수가 특별한 값을 리턴하게 만듦

       1. 특별한 값이 EOF
       2. 파일 끝 탐지 시 getchar()함수의 리턴값이 EOF
       3. EOF는 stdio.h 파일에

          #define EOF (-1)이라고 정의

- 파일 복사 원리
  - echo_eof.c
    ```java
    #include<stdio.h>
    int main(void){
    		int ch;
    		while((ch= getchar()) != EOF){ // EOF의 경우 stdio.h가 알아서 처리하므로 직접 정의할 필요가 없다.
    				putchar(ch);
    		}
    		return 0;
    }
    ```
  - 이 프로그램은 사용자가 제공하는 입력은 무엇이든지 화면에 복사
  - 계속 출력하다 EOF만나면 멈춤
  - 이 프로그램의 출력을 화면이 아닌 파일로 향할수 있도록 지정할 수 있다 가정
    - 사용자는 키보드로 데이터 입력할 수 있고 입력한 데이터를 파일로 저장시키는 용도로 echo_eof.c를 사용 가능
    - 파일로부터 입력을 echo_eof.c로 향하게 하고, 출력은 또 다른 파일로 향할 수 있게 함.
    - echo_eof.c를 파일 복사하는 용도로 사용할 수 있을 것 !
  - 핵심은 입력과 출력의 흐름을 제어!

## 리디렉션과 파일

- 프로그램이 파일을 다루는 방법
  1. 파일을 열고 → 닫고 → 읽고 → 쓰는 작업을 할 수 있는 특별한 함수들을 명시적으로 사용
  2. 키보드와 화면을 처리하도록 설계된 프로그램을 사용하되, 다른 채널을 사용하도록 입력과 출력을 리디렉션 하는 것
     1. stdin 스트림을 파일로 재지정
     2. getchar()프로그램은 스트림으로 부터 데이터를 계속 제공바드는데 데이터를 어디서 얻는지 상관하지 않음 → 리디렉션 예시

## 명령프롬프트 리디렉션

1. 입력 리디렉션

```java
echo_eof < words
```

- words파일을 stdin 스트림에 연결하여 파일의 내용이 echo_eof 프로그램 안으로 들어가게 한다.
- echo_eof프로그램은 입력이 키보드가 아니라 파일에서 들어오는지 알지 못한다.
- 프포그램은 문자들의 스트림이 자신에게 들어오는 것 만 안다.

1. 출력 리디렉션

```java
echo_eof > mywords
```

- echo_eof가 키보드입력을 mywords라는 파일로 보내게 하고 싶을 때
- > 라는 연산자는 mywords라는 새로운 파일을 만들고, echo_eof 출력을 그 파일로 리디렉션함

1. 결합 리디렉션

```java
echo_eof < mywords > savewords
```

- mywords 파일의 사본을 만들어 savewords라고 부르고 싶다고 가정

## getchar()와 scanf()

- getchar()는 스페이스,탭,개행 포함한 모든 문자를 읽음
- scanf()는 수를 읽을 때 스페이스, 탭, 개행문자 건너뜀

## gets()함수의 보안결함

- 매개변수로 메모리의 주소를 받지만 얼마나 써도 되는지 크기를 확인하지 않아 발생
- 메모리 경계를 벗어난 쓰기를 수행
- 보안문제가 발생하지 않도록 코드 수준에서 대응하는 것이 중요 (시큐어 코딩)
- 요즘은 애초에 못쓰게 gets_s만 허용하게 함
- 만약 gets_s를 쓰면
- 리눅스와 유닉스에서는

```c
char szBuffer[8]={0};
fgets(szBuffer,8,stdin);
```

## 개행문자 제거

- scanf는
  - 개행을 입력해야 종료가 된다.
  - 마지막에는 \n추가 (16진수로 \A)
  - “%c”에 맞게 읽어와서 메모리에 저장한다! (변수는 메모리를 쓴다)
  - 한글자를 읽어와서 어딘가에 저장해야하기에 scanf_s(”%c”,&ch,1);를 통해 입력받을 때는 목적지 주소를 넣어준다!
  - 정수 두개 입력받고 싶을때
    scanf_s(”%d%d”,&x,&y);
    형식문자 사이에 공백이 없다!
  - scanf_s에 형식문자 \n을 넣지 않을것!
    scanf_s(”%d\n,&input);
- 개행문자 제거

  ```c
  scanf("%d",&나이);
  gets_s(szName,sizeof(szName));
  ```

  - 버퍼에 \n이 남아있는 상황에서 gets를 쓰면 → 입력이 끝났다고 생각함!
  - 사용자의 입력을 안받게 됨!
  - “%c%\*c” - \*c는 한글자를 읽어서 버퍼에서 아예 없어버려라!
  - to-be

  ```c
  scanf("%d%\*c",&나이);

  ```

## 형식문자기반 문자열 입력

gets()는 빈 공백을 집어넣어도 입력되는데 scanf는 빈공백이 있으면 아예 잘라버린다.!

```c
char szBuffer[32]={0};
scanfs_s("%s",szBuffer,(unsigned)_countof(szBuffer));
```

- \_countof라는 매크로로 해결가능
  - 빈칸 대신 개행으로도 가능하지만
  - 개행을 쓸거면 웬만하면 gets_s를 할것!
