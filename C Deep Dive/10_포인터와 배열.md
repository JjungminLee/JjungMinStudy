## 배열

- 배열은 초기화 해서 써야한다.

```java
int no_data[SIZE]; //이건 초기화 시키지 않은 배열
```

## C언어 배열이 인덱스 검사 안하는 이유

- C에서 배열범위를 벗어나는 인덱스를 사용할 경우 프로그램이 다른 변수의 값을 변경하는 결과를 낳는다.
- 왜 그러지? → 범위를 검사하지 않음으로써 프로그램을 빠르게 실행시키기 위함

## 포인터와 배열

- 배열의 이름은 첫번째 원소의 주소이다.

```java
kathy = &kathy[0]
```

- 배열의 경우 주소가 다음 바이트가 아닌 다음 원소의 주소가 증가하는 것을 의미.
- 포인터에 1을 더한다 < = > 포인터가 가리키는 객체의 바이트 수 크기 만큼 포인터 값이 증가
- 주소가 같다.

```java
dates+2 = &dates[2]
```

- 값이 같다.

```java
*(dates+2) = dates[2];
```

## 함수,배열,포인터

- 어떻게 배열이랑 포인터를 같이 쓸 수 있을까?

  - marbles라는 배열이 있고, ar이라는 포인터가 있다고 해보자.
  - ar은 marbles의 첫번째 원소를 가리키는 포인터이기 때문에 배열 표기에 포인터 ar을 사용할 수 있다.

- 포인터 매개변수
  - 배열을 조작하는 함수는 어디에서 시작하고 어디에서 끝나는지 알아야 한다.
  - 배열에서 어느 원소에 접근할 것인지 나타내기 위해 인덱스 사용하는 대신 배열의 원소를 차례대로 가리킬 수 있도록 함수가 포인터 자체의 값을 변경할 수 있다.
- 간단한 포인터 계산 프로그램

```java
int main(){

	int marbles[10]={20,10,...};
	long answer;
	answer = sump(marbles,marbles+10);

}

int sump(int* start,int* end){

	int total = 0;

	while(start<end){
			total += *start; // *(start+i)
			start++;
	}

	return total;

}
```

- 배열을 처리하는 함수는 포인터를 전달인자로 사용

## 포인터 연산

- 대입하기
  - 포인터에 주소를 대입할 수 있다!
- 값 구하기
  - 역참조
  - \*ptr1 이런식으로 주소에 저장되어있는 값을 알아낼 수 있음
- 포인터 주소 얻기
  - &연산자를 통해 포인터 자체가 어디에 저장되어있는지 알 수 있음
- 포인터에 정수 더하기
  - 포인터에 정수 더하거나 정수에 포인터 더하기 위해 + 연산자 사용
  - ptr+4가 &urn[4]와 같아지게 만든다.
- 포인터 증가시키기
  - 배열의 한 원소를 가리키는 포인터를 증가시키면 그 포인터가 배열의 다음 원소 가리키게됨.
- 포인터에서 정수 빼기
  - - 연산자를 사용한다.
  - 예를 들어 ptr이 &urn[4]를 가리키고 있었다면
  - ptr-2 는 &urn[2]와 같다.
- 포인터 감소시키기
  - 증가시키기의 반대
- 포인터 사이의 차 구하기
  - ptr2-ptr1이 2라면 이것은 두 포인터가 2바이트가 아니라 2개의 Int형 크기만큼 떨어져있는 객체들을 가리키는 것을 의미
- 포인터 비교하기
  - 두 포인터가 같은 데이터형을 가리키는 경우 두 포인터의 값을 비교하기 위해 관계연산자 사용 가능

C는 어떤 배열이 주어졌을 때 배열의 원소를 가리키는 포인터와 마지막 원소 바로 다음의 위치를 가리키는 포인터가 유효한 포인터라고 보장함.

이 범위를 벗어났을 때 어떤 결과가 나오는지 정의하지 않는다.

## 초기화 되지 않은 포인터 내용을 역참조 하지 말 것!

```java
int *pt;
*pt=5;
```

- 초기화 되지 않은 경우 pt는 무작위 값을 가지게 된다.
- 그래서 5가 어디에 저장될지 알 수 없다.
- **포인터를 생성하면 포인터 자체를 저장하기 위한 메모리만 할당이 되지, 데이터를 저장하기 위한 메모리는 할당되지 않는다.**
- 포인터를 사용하기 전 반드시 이미 할당된 메모리 위치를 그 포인터에 대입해야한다!

```java
int urn[3];
int* ptr1, int* ptr2;

// 유효한 문장
ptr1++;
ptr2 = ptr1+2;
ptr2 = urn+1;

//무효한 문장
urn++;
ptr2 = ptr2+ptr1;
ptr2 = urn*ptr1;
```

- 유효한 문장:

1. **`ptr1++;`**: 이 문장은 포인터 **`ptr1`**을 다음 메모리 위치로 이동시키는 것으로 유효합니다. 이는 포인터 산술(pointer arithmetic)을 사용한 것입니다.
2. **`ptr2 = ptr1 + 2;`**: 이 문장은 **`ptr1`**이 현재 가리키는 위치에서 두 칸 뒤의 메모리 위치를 가리키는 포인터 **`ptr2`**를 만드는 것으로 유효합니다. 다시 한 번 포인터 산술을 사용했습니다.
3. **`ptr2 = urn + 1;`**: 이 문장은 배열 **`urn`**의 첫 번째 요소 다음의 메모리 위치를 가리키는 포인터 **`ptr2`**를 만드는 것으로 유효합니다.

- 무효한 문장:

1. **`urn++;`**: 이 문장은 배열 자체를 증가시키려고 시도합니다. 배열은 수정할 수 없으므로 무효입니다.
2. **`ptr2 = ptr2 + ptr1;`**: 이 문장은 두 포인터를 더하려고 시도하는데, 이는 일반적으로 무효입니다. 포인터 간의 덧셈은 두 포인터가 동일한 유형을 가리킬 때만 정의되어 있습니다.
3. **`ptr2 = urn * ptr1;`**: 이 문장은 포인터를 곱하려고 시도하는데, 포인터 간의 곱셈은 정의되어 있지 않습니다. 두 포인터를 곱하는 것은 의미가 없습니다.

- 정리
  - 메모리 위치를 이동시키는 것은 유효함
  - 배열자체나 포인터 자체를 변화시키는 것은 무효함

## 배열 내용의 보호

- 프로그램이 값을 변경할 필요가 없다면 → 수량을 값으로 전달하는 것이 좋음
- 프로그램이 값을 변경할 필요가 있다면 → 포인터를 전달
- 배열의 경우 포인터를 전달해야함!

- 효율성에 대한 논의
  - 함수가 어떤 배열을 값으로 전달한다면 원본 배열의 복사본을 저장할만큼의 공간을 할당해야함
  - 고로 배열의 주소를 전달하고, 함수가 원본 데이터를 가지고 작업할 수 있도록 하는게 훨씬 빠름
  - 이것이 C++에서 레퍼런스를 사용하는 이유가 아닐까?!
- 그치만 단점!
  - C가 데이터를 값으로 전달하는 이유는 데이터의 무결성을 유지하기 위함!

## 형식 매개변수에 const사용하기

- 함수의 의도가 배열내용을 변경하지 않는 것이라면 프로토타입과 함수 정의에서 형식매개변수를 선언할 때 키워드 const를 사용한다.

```java
const int days[MONTH] ={30,29,28,27,..};
days[9]=44;
```

- 상수를 가리키는 포인터는 값을 변경하는데 사용할 수 없다!
- 함수 매개변수에서 const 사용하는 경우 데이터를 보호할 뿐만 아니라 const로 선언된 배열과 함수가 함께 동작하도록 해준다.

```java
void show_array(const double *ar,int n);
```

- 여기 ar에 일반배열과 const배열 모두 받아들일 수 있다.
- 상수를 가리키는 포인터에 대입될 수 있기 때문!
- 왜냐하면 상수데이터의 주소나 상수가 아닌 데이터의 주소를 상수를 가리키는 포인터에 대입하는 것이 유효하기 때문!

```java
double rates[5] ={0,0,0,0,0};
const double locked[4]={0,0,0,0};
const double *pc = rates;
pc = locked;
pc = &rates[3];
```

- 고로 const를 사용하면 데이터를 보호할 뿐만 아니라 const로 선언된 배열과 함수가 함께 동작하도록 해준다.

## 포인터와 다차원 배열

```java
int zippo[4][2];
```

- zippo가 배열의 첫번째 원소의 주소이므로 zippo는 &zippo[0]과 같은 값을 가진다.
- 사실 zippo와 &zippo[0]은 같은 수치값을 가진다.
- 하지만 zippo[0]은 int형 1개 크기 객체의 주소이고, zippo는 int형 2개 크기의 객체 주소이다
- 고로 zippo[0]+1과 zippo+1의 값이 달라지게된다.
- zippo[0]은 zippo[0][0]의 주소이다. \*(zippo[0])는 zippo[0][0]에 저장되어있는 하나의 int형값을 나타낸다.
- \*zippo는 zippo[0]을 나타낸다.

```java
zippo[2][1]
```

- - ( \* (zippo+2) +1)

## 다차원 배열을 가리키는 포인터

```java
int zippo[2][2]={{0,0},{0,0}};
int (*pz)[2];
pz = zippo;
```

- 이런식으로 int (\*pz)[2]를 통해 가리키기 가능!

## 포인터 호환성

- const포인터를 const아닌 포인터에 가리키는 것은 위험하다!
- const아닌걸 const포인터에 가리키는건 가능!

## 함수와 다차원 배열

- 만약에 다차원 배열을 매개변수로 넘겨야 한다면 어떻게 해야할까?

```java
int junk[2][3] = {{1,2,3},{4,5,6}};

void func(int (*pt)[4]);
또는
void func(int pt[][4]);
```

- 비어있는 각괄호는 pt가 포인터임을 나타냄
- pt[][] → 이런거는 잘못된 선언이다.

## 가변길이 배열 (VLA)

- 지금까지는 열의 길이를 숫자로 짱박아뒀다.
- 하지만 가변길이 배열을 사용하면 그렇게 하지 않아도 된다!

```java
int sum2d(int rows,int cols, int ar[rows][cols]);
```

- 중요한건 매개변수에 있는 VLA선언이 실제로 배열을 선언하는 것은 아니라는 점!
- VLA의 이름은 포인터이고, VLA 매개변수를 사용하는 함수가 원본 배열에 들어있는 데이터를 가지고 작업하며 전달인자로 전달되는 배열을 변경할 수 있는 능력을 가진다는 것을 의미
- 가변길이 배열은 동적 메모리 할당을 지원
