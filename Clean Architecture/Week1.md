# 1주차

## 설계와 아키텍쳐란?

### 설계와 아키텍쳐 개념잡기

- 설계와 아키텍쳐의 구분은 무의미
- 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소
- 소프트웨어 아키텍처의 목표 : 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화 하는 것

### 나쁜 소프트웨어 설계란?

- 개발자는 코드는 나중에 정리하면 된다고 생각하고 당장 시장에 출시하는 것에만 몰두
  - 기능 추가에만 몰두하여 소스코드는 엉망진창이 되고 생산성은 0에 수렴
  - 개발자는 생산성을 유지할 수 있다고 자신의 능력 과신
  - “지저분한 코드를 작성하면 단기간에는 빨리 갈 수 있고 장기적으로 볼 때만 생산성이 낮아진다”
    → 완전히 잘못됨
    → 엉망으로 만들면 깔끔하게 유지할 때 보다 항상 더 느리다

### 소프트웨어의 가치

1. 행위
   1. 기계가 요구사항을 위반하면 디버깅하며 문제를 고치는것이 프로그래머가 할 일의 전부라 생각 → 틀림
2. 아키텍쳐
   1. 소프트웨어라는 단어에서 느낄 수 있듯이 ‘부드러움’을 지니도록 만들어야함
   2. 변경하기 쉬워야 한다

- 동작이 더 중요할까? 시스템을 변경가능하게 만드는 것이 더 중요할까?
- 긴급하지만 중요한 기능과 긴급하지만 중요하지 않은 기능을 구분하는 것이 매우 중요하다!
- 아키텍쳐가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

## 벽돌부터 시작하기 : 프로그래밍 패러다임

### 구조적 프로그래밍

- 최초로 적용된 패러다임
- 데이크 스트라 ?(내가 아는 한정점에서 모든정점으로 가는 다익스트라??!)
  - goto문이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 된다
- 분기
  - 열거법을 재적용하는 방식
  - 두 경로가 수학적으로 적절한 결과를 만들어낸다면 증명은 신뢰할 수 있게 됨
- 반복
  - 귀납법 사용해서 반복이 올바름을 증명
- 테스트
  - 테스트는 버그가 있음을 보여줄 뿐 버그가 없음을 보여줄 수는 없다
  - 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만 프로그램이 맞다고 증명할 수는 없다

### 객체지향 프로그래밍

- 구조적 프로그래밍 보다 2년 앞서 등장
- 제어 흐름의 간접적인 전환에 대해 규칙을 부과
- 캡슐화
  - 멤버 변수나 함수가 어떻게 구현되었는지 조금도 알지 못하는것
- 상속
  - 암묵적으로 업캐스팅을 사용
- 다형성
  - 함수를 가리키는 포인터를 응용한 것
  - 포인터는 다형적 행위를 만드는 데 위험
  - 다형성이 뭐가 좋지?
    - 장치 독립적 (O) 장치 의존적 (X)
- 의존성 역전
  - 전형적
    - main함수 → 고수준 함수 호출 → 중간수준 함수 호출
    - 의존성의 방향은 `제어흐름`을 따르게 됨
    - 고수준함수를 호출 할 때 ⇒ #include, import, using
    - 모든 호출 함수는 피호출 함수가 포함된 모듈의 이름을 명시적으로 지정해야함
    - 소프트웨어 아키텍트에게 선택지는 별로 없음 → 제어의 흐름은 시스템의 행위에 따라 결정, 소스 코드의 의존성은 제어 흐름에 따라 결정
  - 다형성이 끼어들면?
    - 다형성을 안전하고 편리하게 제공한다 ⇒ 소스코드 의존성을 어디서든 역전시킬 수 있다
    - 소스코드의 의존성은 인터페이스를 추가함으로써 방향을 역전시킬 수 있다
- 배포 독립성과 개발 독립성
  - 업무 규칙이 데이터베이스와 UI에 의존하는 대신 소스 코드의 의존성을 반대로 배치하여 데이터베이스와 UI가 업무 규칙에 의존하게 만들 수 있다
  - 업무 규칙의 소스코드에서는 UI나 DB를 호출하지 않는다
  - 업무 규칙을 포함하는 컴포넌트는 UI와 데이터 베이스를 포함하는 컴포넌트에 의존하지 않기에 독립적으로 배포 가능 → 특정 컴포넌트의 소스코드가 변경되면 해당 코드가 포함된 컴포넌트만 다시 배포하면 됨
    ⇒ 배포독립성이라고 함!
  - 시스템의 모듈을 독립적으로 배포 → 서로 다른 팀에서 각 모듈 독립적으로 개발 가능 ⇒ 개발 독립성

### 함수형 프로그래밍

- 할당문에 대해 규칙을 부과
- 함수형 언어에서 변수는 변경되지 않는다
- 경합 조건, 교착상태 조건, 동시 업데이트 모두 가변변수로 인해 발생
- 락이 가변적이지 않다면 → 교착상태 일어나지 않음
- 애플리케이션을 제대로 구조화 하려면 변경하려는 컴포넌트와 변경하지 않는 컴포넌트 분리를 해야함

### 이벤트 소싱

- 상태가 아닌 트랜잭션을 저장하자!
- 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션 처리
- 데이터 저장소
  - 삭제되거나 변경되는 것이 하나도 없다
  - CR만 수행
  - 저장공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고 완전한 함수형으로 만들 수 있다
    - 소스코드 버전관리 시스템이 그 예시!

소프트웨어는 순차,분기,반복,참조로 구성된다

## 설계 원칙

- 좋은 소프트웨어는 깔끔한 코드에서부터 시작
- 좋은 코드로 좋은 아키텍쳐를 정의하는 원칙 ⇒ SOLID
- SOLID
  - 변경에 유연
  - 이해하기 쉬움
  - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반

### SRP

- 단일 책임 원칙
- 소프트웨어 시스템이 가지는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받음
- 소프트웨어 모듈은 변경의 이유가 하나여야 함
- 하나의 모듈은 하나의 사용자 또는 이해 관계자에 대해서만 책임져야 한다.
- 모듈? → 소스 파일 / 함수와 데이터 구조로 구성된 응집된 집합
- 응집된 → SRP
- 우발적 중복
  - 서로 다른 액터가 의존하는 코드는 서로 분리하라고 말함
- 병합
  - 소스 파일에 다양하고 많은 메서드를 포함하면 병합이 많이 발생
  - 다른 목적으로 소스파일을 변경하는 경우에 해당
  - 해결책 : 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것
- Solution?
  - 데이터와 메서드를 분리하는 것
  - 퍼사드 패턴
    - **_파사드 패턴_**은 일련의 저수준 인터페이스들을 하나의 고수준 인터페이스로 묶어주는 **_패턴_**
    - Emplyoee Facacde나 Employee 클래스가 그 역할을 함
- Recap
  - SRP는 메서드와 클래스 수준의 원칙
  - 컴포넌트 수준에서는 공통 폐쇄 원칙
  - 아키텍쳐 수준에서는 아키텍쳐 경계의 생성을 책임지는 변경의 축

### OCP

- 개방-폐쇄 원칙
- 기존 코드 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것

### LSP

- 리스코프 치환 원칙
- 하위타입에 대한 유명한 원칙
- 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면 구성요소는 반드시 서로 치환 가능해야함

### ISP

- 인터페이스 분리 원칙
- 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 함

### DIP

- 의존성 역전 원칙
- 고수준 구현 코드느는 저수준 세부사항 코드에 절대 의존해서는 안됨

### 캐시 질문

- 그래서 그 제어흐름이라는게 뭘까여? (p.49)
- 결국 인터페이스를 통해 소스코드의 의존성을 원하는 방향으로 설정?
  - MSA 아키텍쳐
    - 아웃바운드 포트도 디비에 대한걸 아는게 아니라 인터페이스로
    - “추상계층 하나 놓으면 다 해결할 수 있다” 라는말과 일맥상통
- 컴포넌트와 클래스의 차이는 뭘까요?(p.71)
