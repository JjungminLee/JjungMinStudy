# 2주차

### 🛠 OCP : 개방폐쇄 원칙

- 확장에는 열려있어야 하고 변경에는 닫혀있어야 한다.
  - 개체의 행위는 확장할 수 있어야 하지만 이때 개체를 변경해서는 안된다.
- 소프트웨어 아키텍쳐가 훌륭하다면?
  - 변경되는 코드의 양이 가능한 최소화 될 것
    - 서로 다른 목적으로 변경되는 요소 적절히 분리 : SRP
    - 이들 사이의 의존성 체게화 : DIP
- 모든 컴포넌트는 단방향으로 이루어짐
  - Presenter에서 발생한 변경 → Controller보호
  - View에서 발생한 변경 → Presenter 보호
  - Interector(가장 높은 수준의 정책 포함) → 다른 모든 곳에서 발생한 변경으로 부터 보호
- 기능을 분리 + 기능을 계층구조로 조직화
- 추이 종속성 : 자신이 직접 사용하지 않는 요소에는 절대 의존해서는 안된다는 소프트웨어 원칙 위반
- Recap
  - 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있음
  - 시스템을 컴포넌트 단위로 분리하고 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야함

### 🛠 LSP : 리스코프 치환원칙

- 상속을 하도록

### 🛠 ISP : 인터페이스 분리 원칙

- 정적타입으로 선언 됐을 때
- 의존성으로 인해 다른 메서드를 전혀 사용하지 않더라도 소스코드가 다른 메서드에 의존하게 됨.
- 컴파일 후 새로 또 배포해야하는 문제
- 인터페이스를 둠으로써 해결

### 🛠 DIP : 의존성 역전 원칙

- 유연성이 극대화된 시스템
  - 의존성이 추상에 의존 , 구체에는 의존하지 않음
  - 인터페이스는 변동이 낮다
- 안정된 소프트웨어
  - 변동성이 큰 구현체에 의존하는 일 지양, 안정된 추상 인터페이스 선호
- 안정된 추상화를 위한 3원칙
  1. 변동성이 큰 구체 클래스 참조하지 말 것
  2. 변동성이 큰 구체 클래스로부터 파생하지 말 것
  3. 구체 함수를 오버라이드 하지 말 것
  4. 구체적이고 변동성이 크다면 절대로 그 이름을 언급하지 말 것
- 팩토리
  - 바람직하지 못한 의존성을 처리할 때 추상팩토리를 사용하곤 함
  - 소스코드의 의존성은 해당 곡선과 교차할 때 모두 한방향, 즉 추상적인쪽 향함
  - 의존성 관리하기 위해 추상 팩토리 패턴 사용
  - 추상컴포넌트 : 애플리케이션의 고수준 업무
  - 구체 컴포넌트 : 업무규칙을 다루기 위해 필요한 모든 세부사항
  - 제어의 흐름은 소스코드의 의존성과는 정반대 방향으로 흐름
  - 소스코드 의존성은 제어 흐름과 반대방향으로 역전! → 의존성 역전
- 의존성은 더 추상적인 엔티티가 있는 쪽으로만 향함 → 의존성 규칙이라 부름

### 🛠 컴포넌트 원칙

### 컴포넌트

- 배포단위
- java → jar
- 잘 설계된 컴포넌트라면 반드시 독립적으로 배포가능한 , 독립적으로 개발 가능한 능력을 갖춰야함
- 동적 링크 파일도 소프트웨어 컴포넌트라고 함

### 컴포넌트 응집도

- 어떤 클래스를 컴포넌트에 포함시켜야 하지?
  - REP : 재사용/릴리즈 등가 원칙
  - CCP : 공통 폐쇄 원칙
  - CRP : 공통 재사용 원칙
- REP (재사용을 위한)
  - 재사용 단위 == 릴리즈 단위
  - 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어서는 안된다
  - 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다.
  - 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어 있어야 한다.
- CCP (유지보수를 위한)
  - 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라
  - 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
  - SRP를 컴포넌트 관점에서 다시 쓴 것
  - 변경 가능성이 있는 클래스를 모두 한곳으로 묶는 것을 권함
- CRP (불필요한 릴리스를 피하기 위한)
  - 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라
  - 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 함
  - 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없음

### 컴포넌트 결합

- ADP : 의존성 비순환 원칙
  - 순환이 생기면
    - 간단한 단위테스트를 할 때도 수많은 라이브러리와 다른 사람들의 작업물까지 포함해야함
    - 컴포넌트를 분리하기 상당히 어려워짐
  - 순환 끊기
    - 의존성 원칙 사용 ⇒ 중간에 인터페이스를 생성함으로써 의존성을 끊기
    - 순환이 생긴 컴포넌트가 모두 의존하는 새로운 컴포넌트 만들기
- SDP : 안정된 의존성 원칙
  - 안정성 방향으로 (더 안정된 쪽에) 의존하라.
  - 안정성 ?
    - 변경하기 어렵게 만드는 것
  - 안정성이란
    - 결국 의존을 많이 하는 것
  - 모든 컴포넌트가 안정적인 시스템 → 변경이 불가 ⇒ 바람직한 상황이 아님
  - 위쪽에 변경 가능한 컴포넌트 , 아래에 안정된 컴포넌트에 의존 ⇒ 바람직한 상황
- SAP : 안정된 추상화 원칙
  - 컴포넌트는 안정된 정도 만큼 추상화 되어야 한다.
  - 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 대응할 수 있을정도로 충분히 유연하게 만들 수 있을까? → OCP
  - 안정적인 컴포넌트 : 인터페이스와 추상클래스로 구성되어 쉽게 확장할 수 있어야 함.
