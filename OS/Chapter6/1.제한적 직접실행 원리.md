### 제어를 유지하면서 효과적으로 가상화하는 방법

- 가상화를 구현하기 위해 해결해야하는 문제
  1. 성능저하
     시스템에 과도한 오버헤드를 주지 않으면서 가상화 구현
  2. 제어 문제
     CPU에 대한 통제를 유지하면서 프로세를 효율적으로 실행
     제어권 상실시, 한 프로세스가 영원히 실행될 수도 있고, 접근해서는 안되는 정보에 접근 할 수도

### 제한적 직접 실행

- 프로그램을 CPU 상에 직접 실행
- 시분할을 실행하지 못한다!

### 제한연산을 수행하는 방법

#### ⚠️ 문제점1

- 프로세스는 입출력 연산을 비롯한 다른 제한 연산을 수행해야한다.
- 문제는 프로세스는 시스템에 대한 권한이 없기에 제한된 연산을 수행할 수 없다!

#### ✅ 하드웨어가 제공하는 두가지 실행모드

1. 사용자 모드 : 응용프로그램은 하드웨어 자원에 대한 접근권한이 일부 제한됨
2. 커널모드

- 컴퓨터의 모든 자원에 대한 접근권한은 커널모드에서 가짐.

- 커널모드로 진입하기 위한 trap명령어와 사용자 모드로 돌아가기 위한 return-from-trap 명령어가 제공됨

- 운영체제가 하드웨어에게 트랩 테이블의 메모리 주소를 알려주기 위한 명령어도 함께 제공

#### 😭 사용자 프로세스가 디스크 읽기 같은 특권 명령어를 실행해야할 때는?

- 하드웨어는 사용자 프로세스에게 시스템콜 제공
- 시스템콜을 실행하기 위해 프로그램은 trap 특수명령어를 실행해야한다.
- 커널안으로 분기하는 동시에 특권수준을 커널모드로 상향조정한다
- cf) c 라이브러리의 open과 시스템콜 open은 엄연히 다름, 시스템콜은 trap 실행, c라이브러리는 어셈블리어로 구현됨

#### 😲 trap이 운영체제 코드의 어디를 실행할지 어떻게 알까?

- 호출한 프로세서는 분기할 주소를 명시할 수 없다.
- 주소를 명시한다는 것은 커널 내부의 원하는 지점을 접근할 수 있다는 것
- 커널이 임의의 코드를 실행하기 위해서는접근 권한 검사가 끝난 후 분기해야함.
- 커널은 trap발생 시 어떤 코드를 실행할지 신중히 통제해야함

#### 🧩 커널은 어떻게 대응할까?

- 커널은 부팅시에 트랩 테이블을 만들고 이를 이용해 시스템을 통제
- 컴퓨터가 부팅 될 때는 커널모드에서 동작하기에 하드웨어를 원하는대로 제어 가능!
- 운영체제가 하는 초기 작업 중 하나는 하드웨어에게 예외사건이 생겼을 때 어떤 코드를 실행해야하는지 알려줌
  - 만약 키보드 인터럽트 발생시, 운영체제는 특정 명령어 사용해 하드웨어에게 트랩 핸들러의 위치 알려줌
  - 하드웨어는 해당위치를 기억하고 있음.
  - 따라서 시스템콜과 같은 예외사건이 발생했을 때도 무엇을 해야할지 알 수 있음

### 보안상 사용자의 입력값을 주의해야하는 이유

- 시스템콜의 인자로 전달된 값들이 제대로된 값인지 반드시 검사해야한다.
- 올바르지 않은 주소를 전달한다면 커널 메모리를 모두 읽는 일 발생할 수도

### Recap

- 모든 시스템콜은 자신의 고유번호를 가진다!
- 사용자 프로그램은 원하는 시스템콜을 호출하기 위해 해당 시스템 콜 번호를 레지스터 또는 스택의 지정된 위치에 저장한다.

- trap 명령어를 호출한다.

- 라이브러리가 수행함 (표준 C라이브러리)
- trap명령어가 호출되면 명령어 처리하는 trap 핸들러 실행!

- trap핸들러는 운영체제의 일부분
- 유효한 시스템콜 번호임이 확인되면 해당 코드로 이동하여 실행
- 각 시스템콜 코드의 위치도 운영체제만 알고 있음 (사용자 프로그램은 모름!)
